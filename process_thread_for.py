from concurrent.futures import ThreadPoolExecutor
from multiprocessing import Pool, freeze_support
import time


def _factorial(some_value: int) -> int:
    fact = 1
    for i in range(1, some_value+1):
        fact = fact * i
    return fact


# start = time.time()
# if __name__ == '__main__':
#     print('-----------------------------------------------------')
#     with Pool(3) as p:
#         print(p.map(_factorial, [20, 40, 60]))
# end = time.time() - start
# print('-----------------------------------------------------\nTIME:')
# print(end) #Отработало с этими знаениями на моем компе за половину секунды
# print('-----------------------------------------------------')

start = time.time()
with ThreadPoolExecutor(3) as executor:
    res = executor.map(_factorial, [400000000, 600000000, 8000000000])
for i in res:
    print(i)
end = time.time() - start
print('-----------------------------------------------------\nTIME:')
print(end) #Отработало гораздо быстрее, чем процессы
#Запускал их по очереди, тк если запускал процессы совместно с потоками то получал какую-то лабуду
#Наблюдение: алгоритмические операции по типу логарифма решились быстрее в потоках, нежели в процессах
#Вывод: создание процессов отнимает у компьютера довольно много ресурсов и из-за этого по моему мнению
#и вышла такая разница во времени, таким образом, для подобных операций(не ресурсоемких) гораздо
#выгоднее по ресурсам использовать потоки, однако, если бы числа были гораздо гораздо больше
#то процессы оказались бы быстрее, тк работали бы параллельно в отличие от потоков
#боюсь ранать на своем слабеньком ноуте нереальные числа, поэтому как есть, всю суть уловил, и
#надеюсь, передал